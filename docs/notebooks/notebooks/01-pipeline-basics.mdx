---
title: Pipeline Basics
---




export const quartoRawHtml =
[`<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
`,`
<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Stage</th>
<th data-quarto-table-cell-role="th">Input</th>
<th data-quarto-table-cell-role="th">Output</th>
<th data-quarto-table-cell-role="th">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>load_documents</td>
<td>Directory path</td>
<td>List[Document]</td>
<td>Read files from disk into Document objects</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>chunk_text</td>
<td>List[Document]</td>
<td>List[Chunk]</td>
<td>Split documents into fixed-size overlapping chunks</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>embed_chunks</td>
<td>List[Chunk]</td>
<td>List[Vector]</td>
<td>Convert text chunks to vector embeddings</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>retrieve_context</td>
<td>Query + List[Vector]</td>
<td>List[Chunk]</td>
<td>Rank and select top-k relevant chunks</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>generate_answer</td>
<td>Query + List[Chunk]</td>
<td>String</td>
<td>Prompt LLM with context to produce final answer</td>
</tr>
</tbody>
</table>
`,`
</div>`];

An **AI pipeline** is a sequence of processing steps that transform raw
input into a final output. Each step performs a discrete task — data
loading, preprocessing, inference, post-processing — and passes its
result to the next step.

Pipelines make complex workflows:

-   **Reproducible** — the same input always produces the same output.
-   **Composable** — steps can be swapped, reordered, or extended
    independently.
-   **Observable** — each step’s input and output can be inspected for
    debugging.

## Defining a Pipeline

A pipeline can be represented as a simple list of steps, each with a
name, description, and expected I/O types.


```python
pipeline = {
    "name": "Document Q&A",
    "steps": [
        {"name": "load_documents",   "description": "Ingest raw documents from source directory."},
        {"name": "chunk_text",       "description": "Split documents into overlapping text chunks."},
        {"name": "embed_chunks",     "description": "Generate vector embeddings for each chunk."},
        {"name": "retrieve_context", "description": "Find the most relevant chunks for a query."},
        {"name": "generate_answer",  "description": "Produce an answer using retrieved context."},
    ],
}

print(f"Pipeline: {pipeline['name']}")
print("Steps:")
for i, step in enumerate(pipeline["steps"], 1):
    print(f"  {i}. {step['name']:<20s} — {step['description']}")
```

``` text
Pipeline: Document Q&A
Steps:
  1. load_documents    — Ingest raw documents from source directory.
  2. chunk_text        — Split documents into overlapping text chunks.
  3. embed_chunks      — Generate vector embeddings for each chunk.
  4. retrieve_context  — Find the most relevant chunks for a query.
  5. generate_answer   — Produce an answer using retrieved context.
```

## Pipeline Stage Summary

The table below summarizes each stage’s role, expected input, and
output.


```python
import pandas as pd

stages = pd.DataFrame([
    {"Stage": "load_documents",   "Input": "Directory path",        "Output": "List[Document]", "Description": "Read files from disk into Document objects"},
    {"Stage": "chunk_text",       "Input": "List[Document]",        "Output": "List[Chunk]",    "Description": "Split documents into fixed-size overlapping chunks"},
    {"Stage": "embed_chunks",     "Input": "List[Chunk]",           "Output": "List[Vector]",   "Description": "Convert text chunks to vector embeddings"},
    {"Stage": "retrieve_context", "Input": "Query + List[Vector]",  "Output": "List[Chunk]",    "Description": "Rank and select top-k relevant chunks"},
    {"Stage": "generate_answer",  "Input": "Query + List[Chunk]",   "Output": "String",         "Description": "Prompt LLM with context to produce final answer"},
])

stages
```

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[0] }} />

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[1] }} />

<div dangerouslySetInnerHTML={{ __html: quartoRawHtml[2] }} />

## Next Steps

See [Pipeline Results](02-pipeline-results.ipynb) to learn how to
inspect the output of a pipeline run.
